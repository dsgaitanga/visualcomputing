<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Talleres Computación Visual</title><link>https://dsgaitanga.github.io/visualcomputing/</link><description>Recent content in Introduction on Talleres Computación Visual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dsgaitanga.github.io/visualcomputing/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/shortcodes/p5/div/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/shortcodes/p5/div/</guid><description>p5 div shortcodes embed p5.js code within a div element. There are two p5 div shortcodes: p5-div and p5-instance-div.
p5-div # {{&amp;lt; p5-div ver=&amp;#34;1.4.2&amp;#34; sketch=&amp;#34;/path/to/sketch.js&amp;#34; lib1=&amp;#34;https://cdntolib1/lib1.js&amp;#34; &amp;gt;}} All parameters are optional but sketch. Default values are shown in the above snippet but for libs*. Up to lib5 libs may be specified.
Scintillating grid # Look at this and also this among many more references there are.
p5-div markdown {{&amp;lt; p5-div sketch=&amp;#34;/visualcomputing/sketches/scintillating.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/shortcodes/p5/iframe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/shortcodes/p5/iframe/</guid><description>p5 iframe shortcodes embed p5.js code within an iframe element. There are two p5 iframe shortcodes: p5-iframe and p5-global-iframe.
p5-iframe # {{&amp;lt; p5-iframe ver=&amp;#34;1.4.2&amp;#34; sketch=&amp;#34;/path/to/sketch.js&amp;#34; lib1=&amp;#34;https://cdntolib1/lib1.js&amp;#34; width=&amp;#34;800&amp;#34; height=&amp;#34;600&amp;#34; &amp;gt;}} All parameters are optional but sketch. Default values are shown in the above snippet but for libs*. Up to lib5 libs may be specified.
Color relativity # Look at this brief explanation about what color relativity is.
p5-iframe markdown {{&amp;lt; p5-iframe sketch=&amp;#34;/visualcomputing/sketches/colors.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/PrimerTaller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/PrimerTaller/</guid><description>PrimerTaller # El primer taller consta de dos secciones, en la primera se tratará el tema de ilusiones visuales, apartado donde tenemos 3 ejemplos de ilusiones visuales; en la segunda se hará un procesamiento de imagen con múltiples filtros.
Cada ejemplo mostrado estará dividido en:
El Título del ejercicio Descripción breve del ejercicio Ejercicio implementado en p5.js Instrucciones de uso Código base del ejercicio para observar su funcionamiento Ilusiones Ópticas # Líneas verticales de grosor variable # Se inscribe sobre el canvas una serie de líneas verticales que son más gruesas a medida que se acercan al centro, y también varían respecto a la distancia del mouse hasta el centro, debido a esto, cada vez que se hacen más gruesas las líneas se hace la ilusión de un agujero/circulo negro se hace cada vez más grande.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/SegundoTaller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/SegundoTaller/</guid><description>SegundoTaller # Para la implementación del segúndo taller decidimos usar como base La atracción de Mundo Aventura &amp;ldquo;Ikaro&amp;rdquo;. La complejidad de su implementación radica en la gran cantidad de movimientos que realiza, para lo cual se deben hacer traslaciones y rotaciones anidadas, lo que lo convierte en un proyecto interesante a simular.
Funcionamiento # El mecanismo de esta atracción funciona de la siguiente forma:
El brazo principal sube la rueda cuando la atracción inicia, de forma que pasa de 0 a 90 grados respecto a los ejes X,Y en los primeros segundos.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Coloring/</guid><description>Tercer Taller # Coloring # CMY and RGB Color models # El siguiente canva muestra cómo interpolar los datos de color a lo largo de un triángulo y cómo cambiar entre los modelos de color rgba y cmya
Instrucciones de uso A medida que el ratón se desplaza dentro del lienzo, es posible observar la interpolación de los colores. Presiona:
R: Para aleatorizar el triángulo. C: Para cambiar entre los modelos de color rgba y cmya.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Non-Euclidean-Geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Non-Euclidean-Geometry/</guid><description>Non-Euclidean geometry # Se pueden implementar todo tipo de geometrías no euclidianas creando un enlace entre diferentes lugares del espacio 3D que comparten el mismo punto de vista:
Código Fuente let easycam; let edge = 80; function preload() { // no varyings need to be emitted from the vertex shader texShader = readShader(&amp;#39;/visualcomputing/sketches/non_euclidean.frag&amp;#39;, { varyings: Tree.NONE }); fox = loadModel(&amp;#39;/visualcomputing/sketches/fox.obj&amp;#39;, true); cow = loadModel(&amp;#39;/visualcomputing/sketches/cow.obj&amp;#39;, true); woody = loadModel(&amp;#39;/visualcomputing/sketches/woody.obj&amp;#39;, true); horse = loadModel(&amp;#39;/visualcomputing/sketches/horse.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Procedural-Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Procedural-Texturing/</guid><description>Procedural Texturing # El objetivo del texturizado procedimental es generar una textura de forma procedimental usando un algoritmo de tal manera que el resultado pueda ser mapeado en una forma como una textura. El texturizado procedimental requiere el uso de un objeto frame buffer que en p5.js se implementa como un objeto p5.Graphics.
El programa de abajo utiliza las truchet tiles implementadas en el gran libro de shaders de Patricio Gonzales y Jen Lowe para mapear la textura resultante en el cilindro.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Texturing/</guid><description>Texturing # UV Visualization # El mapeo de texturas es un método para definir detalles de alta frecuencia, texturas superficiales o información de color en un gráfico generado por computadora o en un modelo 3D. La técnica original fue establecida por Edwin Catmull en 1974.
El mapeo de texturas originalmente se refería al mapeo difuso, un método que mapeaba píxeles de una textura a una superficie 3D (&amp;ldquo;envolviendo&amp;rdquo; la imagen alrededor del objeto).</description></item></channel></rss>