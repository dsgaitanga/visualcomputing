<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Talleres Computación Visual</title><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/</link><description>Recent content on Talleres Computación Visual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Coloring/</guid><description>Tercer Taller # Coloring # CMY and RGB Color models # El siguiente canva muestra cómo interpolar los datos de color a lo largo de un triángulo y cómo cambiar entre los modelos de color rgba y cmya
Instrucciones de uso A medida que el ratón se desplaza dentro del lienzo, es posible observar la interpolación de los colores. Presiona:
R: Para aleatorizar el triángulo. C: Para cambiar entre los modelos de color rgba y cmya.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Non-Euclidean-Geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Non-Euclidean-Geometry/</guid><description>Non-Euclidean geometry # Se pueden implementar todo tipo de geometrías no euclidianas creando un enlace entre diferentes lugares del espacio 3D que comparten el mismo punto de vista:
Código Fuente let easycam; let edge = 80; function preload() { // no varyings need to be emitted from the vertex shader texShader = readShader(&amp;#39;/visualcomputing/sketches/non_euclidean.frag&amp;#39;, { varyings: Tree.NONE }); fox = loadModel(&amp;#39;/visualcomputing/sketches/fox.obj&amp;#39;, true); cow = loadModel(&amp;#39;/visualcomputing/sketches/cow.obj&amp;#39;, true); jengi = loadModel(&amp;#39;/visualcomputing/sketches/jengi.obj&amp;#39;, true); horse = loadModel(&amp;#39;/visualcomputing/sketches/horse.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Procedural-Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Procedural-Texturing/</guid><description>Procedural Texturing # El objetivo del texturizado procedimental es generar una textura de forma procedimental usando un algoritmo de tal manera que el resultado pueda ser mapeado en una forma como una textura. El texturizado procedimental requiere el uso de un objeto frame buffer que en p5.js se implementa como un objeto p5.Graphics.
El programa de abajo utiliza las truchet tiles implementadas en el gran libro de shaders de Patricio Gonzales y Jen Lowe para mapear la textura resultante en el cilindro.</description></item><item><title/><link>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsgaitanga.github.io/visualcomputing/docs/talleres/Tercer-Taller/Texturing/</guid><description>Texturing # UV Visualization # El mapeo de texturas es un método para definir detalles de alta frecuencia, texturas superficiales o información de color en un gráfico generado por computadora o en un modelo 3D. La técnica original fue establecida por Edwin Catmull en 1974.
El mapeo de texturas originalmente se refería al mapeo difuso, un método que mapeaba píxeles de una textura a una superficie 3D (&amp;ldquo;envolviendo&amp;rdquo; la imagen alrededor del objeto).</description></item></channel></rss>