[{"id":0,"href":"/visualcomputing/docs/shortcodes/p5/div/","title":"Div","section":"Docs","content":"p5 div shortcodes embed p5.js code within a div element. There are two p5 div shortcodes: p5-div and p5-instance-div.\np5-div # {{\u0026lt; p5-div ver=\u0026#34;1.4.2\u0026#34; sketch=\u0026#34;/path/to/sketch.js\u0026#34; lib1=\u0026#34;https://cdntolib1/lib1.js\u0026#34; \u0026gt;}} All parameters are optional but sketch. Default values are shown in the above snippet but for libs*. Up to lib5 libs may be specified.\nScintillating grid # Look at this and also this among many more references there are.\np5-div markdown {{\u0026lt; p5-div sketch=\u0026#34;/visualcomputing/sketches/scintillating.js\u0026#34; \u0026gt;}} p5-instance-div # {{\u0026lt; p5-instance-div id=\u0026#34;sketchid\u0026#34; ver=\u0026#34;1.4.2\u0026#34; lib1=\u0026#34;https://cdntolib1/lib1.js\u0026#34; \u0026gt;}} // inline sketch code {{\u0026lt; /p5-instance-div \u0026gt;}} Note that the inline sketch should be coded in p5 instance mode syntax. All parameters are optional but id. Default values are shown in the above snippet but for libs*. Up to lib5 libs may be specified.\nLilac chaser # Look at this introductory reference.\np5-instance-div markdown {{\u0026lt; p5-instance-div id=\u0026#34;lilac-chaser\u0026#34; \u0026gt;}} // Adapted from [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/lilacChaser.js) let jump = 0; let count = 0; p5.setup = function() { p5.createCanvas(400, 400); p5.frameRate(7); }; function drawBlurCircles(x, y, r) { p5.push(); p5.noStroke(); var opc = 0.4; var step = 3.0/r; for (var i = r; i \u0026gt; 0; i-=1.5) { if (opc \u0026lt; 5) { opc += step; p5.fill(255, 20, 180, opc); } p5.ellipse(x, y, i, i); } p5.pop(); }; p5.draw = function() { p5.background(200); var numCircles = 12; var stepAngle = 360.0/numCircles; p5.push(); p5.translate(p5.width/2.0, p5.height/2.0); for (var i = 0; i \u0026lt; 360; i = i + stepAngle) { if (i != jump) { p5.push(); p5.rotate(p5.radians(i)); drawBlurCircles(120, 0, 60); p5.pop(); } } if( !p5.mouseIsPressed ) { jump = (jump + stepAngle)%360; } p5.push(); p5.strokeWeight(1.5); p5.line(-7, 0, 7, 0); p5.line(0, -7, 0, 7); p5.pop(); p5.pop(); } {{\u0026lt; /p5-instance-div \u0026gt;}} Note that p5 should be the name to be used for the sketch object variable. Video on canvas # Adapted from here. Don\u0026rsquo;t forget to checkout also the video on dom example.\np5-instance-div markdown {{\u0026lt; p5-instance-div id=\u0026#34;video\u0026#34; \u0026gt;}} let fingers; p5.setup = function() { p5.createCanvas(710, 400); // specify multiple formats for different browsers fingers = p5.createVideo([\u0026#39;/visualcomputing/sketches/fingers.mov\u0026#39;, \u0026#39;/visualcomputing/sketches/fingers.webm\u0026#39;]); fingers.hide(); // by default video shows up in separate dom // element. hide it and draw it to the canvas instead }; p5.draw = function() { p5.background(150); p5.image(fingers, 10, 10); // draw the video frame to canvas p5.filter(p5.GRAY); p5.image(fingers, 150, 150); // draw a second copy to canvas }; p5.mousePressed = function() { fingers.loop(); // set the video to loop and start playing } {{\u0026lt; /p5-instance-div \u0026gt;}} Note that p5 should be the name to be used for the sketch object variable. "},{"id":1,"href":"/visualcomputing/docs/shortcodes/p5/iframe/","title":"Iframe","section":"Docs","content":"p5 iframe shortcodes embed p5.js code within an iframe element. There are two p5 iframe shortcodes: p5-iframe and p5-global-iframe.\np5-iframe # {{\u0026lt; p5-iframe ver=\u0026#34;1.4.2\u0026#34; sketch=\u0026#34;/path/to/sketch.js\u0026#34; lib1=\u0026#34;https://cdntolib1/lib1.js\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} All parameters are optional but sketch. Default values are shown in the above snippet but for libs*. Up to lib5 libs may be specified.\nColor relativity # Look at this brief explanation about what color relativity is.\np5-iframe markdown {{\u0026lt; p5-iframe sketch=\u0026#34;/visualcomputing/sketches/colors.js\u0026#34; width=\u0026#34;725\u0026#34; height=\u0026#34;425 \u0026gt;}} Third party libraries # Example adapted from p5.EasyCam.\np5-iframe markdown {{\u0026lt; p5-iframe sketch=\u0026#34;/visualcomputing/sketches/quick_easycam.js\u0026#34; lib1=\u0026#34;https://cdn.jsdelivr.net/gh/freshfork/p5.EasyCam@1.2.1/p5.easycam.min.js\u0026#34; width=\u0026#34;525\u0026#34; height=\u0026#34;525\u0026#34; \u0026gt;}} Sound # Example took from the p5 examples.\np5-iframe markdown {{\u0026lt; p5-iframe sketch=\u0026#34;/visualcomputing/sketches/sound.js\u0026#34; width=\u0026#34;225\u0026#34; height=\u0026#34;225\u0026#34; \u0026gt;}} p5-global-iframe # {{\u0026lt; p5-global-iframe id=\u0026#34;sketchid\u0026#34; ver=\u0026#34;1.4.2\u0026#34; lib1=\u0026#34;https://cdntolib1/lib1.js\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} // inline sketch code {{\u0026lt; /p5-global-iframe \u0026gt;}} Note that the inline sketch should be coded in p5 global mode syntax. All parameters are optional but id. Default values are shown in the above snippet but for libs*. Up to lib5 libs may be specified.\nBreathing square # Look at this reference for an explanation and further parameterization of the illusion.\np5-global-iframe markdown {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let angle = 0; let speed = 0.06; function setup() { createCanvas(600, 600); } function draw() { background(255, 255, 255); rotateSquare(); if (!mouseIsPressed) { strokeWeight(0); stroke(0); fill(255, 140, 0); rect(0, 0, 281, 281); rect(318, 0, 281, 281); rect(0, 318, 281, 281); rect(318, 318, 281, 281); } } function rotateSquare() { push(); angle += speed; strokeWeight(0); stroke(0); fill(0, 0, 255); translate(width / 2, height / 2); rotate(angle); rect(-187.5, -187.5, 375, 375); pop(); } {{\u0026lt; /p5-global-iframe \u0026gt;}} p5-widget # The p5-widget shortcode embed p5.js code within an p5-widget.\n{{\u0026lt; p5-widget autoplay=true height=\u0026#34;400\u0026#34; width=\u0026#34;400\u0026#34; ver=\u0026#34;1.4.2\u0026#34; \u0026gt;}} // inline sketch code {{\u0026lt; /p5-widget \u0026gt;}} All parameters are optional. Default ver is 1.4.2. For example:\nWidget example # p5-widget markdown {{\u0026lt; p5-widget autoplay=true height=\u0026#34;400\u0026#34; width=\u0026#34;400\u0026#34; ver=\u0026#34;1.4.2\u0026#34; \u0026gt;}} function setup() { createCanvas(300, 300); } function draw() { background(255, 0, 255); } {{\u0026lt; /p5-widget \u0026gt;}} "},{"id":2,"href":"/visualcomputing/docs/talleres/PrimerTaller/","title":"Primer Taller","section":"Talleres","content":" PrimerTaller # El primer taller consta de dos secciones, en la primera se tratará el tema de ilusiones visuales, apartado donde tenemos 3 ejemplos de ilusiones visuales; en la segunda se hará un procesamiento de imagen con múltiples filtros.\nCada ejemplo mostrado estará dividido en:\nEl Título del ejercicio Descripción breve del ejercicio Ejercicio implementado en p5.js Instrucciones de uso Código base del ejercicio para observar su funcionamiento Ilusiones Ópticas # Líneas verticales de grosor variable # Se inscribe sobre el canvas una serie de líneas verticales que son más gruesas a medida que se acercan al centro, y también varían respecto a la distancia del mouse hasta el centro, debido a esto, cada vez que se hacen más gruesas las líneas se hace la ilusión de un agujero/circulo negro se hace cada vez más grande.\nPara su uso, se implementa el mouse, a medida que este se mueve por el canvas se varía la intensidad del grosor de las lineas, siendo más oscuras cuando se acerca al centro y viceversa Código Fuente var pasos; var peso; var radio; function setup(){ createCanvas(500,300); pasos=5; peso=0; radio=5; } function draw(){ background(255); radio=50*(1-norm(Math.sqrt(Math.pow(width/2-mouseX,2)+Math.pow(height/2-mouseY,2)), 0, height)); for(var i=10; i\u0026lt;width;i+=10){ for(var j=0;j\u0026lt;height;j+=pasos){ strokeWeight(radio*(1-norm(Math.sqrt(Math.pow(width/2-i,2)+Math.pow(height/2-j,2)), 0, height))); line(i,j,i,j+pasos); } } fill(255); rect(width-215,height-35,width,height); fill(0); textSize(25); textStyle(BOLD); text(\u0026#39;Intensidad: \u0026#39;+ (radio | 0), width-190,height-10); } Patrón de muaré # Se busca retratar el patrón de Muaré donde se forman patrones de interferencia a gran escala que se puede producir cuando un patrón de rayas opacas con espacios transparentes se superpone a otro patrón similar, como en este caso usando un patrón de círculos que se superponen produciendo un extraño efecto ondulante que distrae nuestra atención.\nPara ajustar la velocidad y dirección del movimiento del circulo rojo, se usa el deslizador inferior. Código Fuente let x=0 let slider; function setup() { createCanvas(500, 500); rectMode(CENTER) slider = createSlider(-4, 4, 0, 0.0001); slider.position((width/2)-40, height); } function draw() { background(40); for(let i=0;i\u0026lt;500;i+=10){ stroke(\u0026#39;purple\u0026#39;) strokeWeight(3) ellipse(x,250,i-500,i-500) noFill() stroke(\u0026#39;blue\u0026#39;) strokeWeight(3) ellipse(width/2,height/2,i,i) } let s = slider.value() if(x\u0026gt;width){ x=0 }if(x\u0026lt;0){ x=width } else{ x=x+s } } Cuadrados con velocidad de rotación fija # Se crea un loop de cuadros donde la velocidad se hace cada vez más rápido de afuera hacia adentro, dando la sensación de la ilusión óptica donde se forman varios patrones de movimiento y formas, e incluso también dando la sensación de que se desacelera en un determinado momento.\nEl deslizador inferior ajusta la velocidad en que rotan los cuadrados. Código Fuente let slider; function setup() { createCanvas(600, 600); rectMode(CENTER); sliderX = 30; sliderY = 20; slider = createSlider(2, 8, 2, 1); slider.position((width/2)-40, height); } function draw() { background(255); fill(255, 150); rect(30, 70, 10, 120, 5); noFill(); translate(300, 300); let s = slider.value() if(s==0){ s=0.2 } for (let x = 420; x \u0026gt;= 40; x = x / 1.08) { rotate(radians(frameCount /s)); noStroke(); fill(127,204,x, 80); rect(0, 0, x, x); } } Procesamiento de imagen # Se crea un canvas con las dimensiones de la imagen y se le aplica un filtro a la imagen en base a una matriz de convolución según la entrada del teclado. Las opciones posibles son:\nFiltro de Sobreexposición # Resalta los bordes de la imagen con lineas claras. Hace uso de la siguiente matriz:\n\\( \\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1\\\\ -1 \u0026amp; 9 \u0026amp; -1\\\\ -1 \u0026amp; -1 \u0026amp; -1 \\end{bmatrix} \\) Filtro de Bordes # Captura los bordes de la imagen y los resalta con lineas blancas, cuyo grosor depende del contraste entre los colores del borde. Todo el resto de la imagen permanece en negro. Hace uso de la siguiente matriz:\n\\( \\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1\\\\ -1 \u0026amp; 8 \u0026amp; -1\\\\ -1 \u0026amp; -1 \u0026amp; -1 \\end{bmatrix} \\) Filtro de Bordes vertical # Repasa la imagen de arriba hacia abajo y captura los bordes encontrados en este eje. El resto de la imagen permanece en negro. Hace uso de la siguiente matriz:\n\\( \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ -1 \u0026amp; 2 \u0026amp; -1 \\end{bmatrix} \\) Filtro de Bordes horizontal # Repasa la imagen de derecha a izquierda y captura los bordes encontrados en este eje. El resto de la imagen permanece en negro. Hace uso de la siguiente matriz:\n\\( \\begin{bmatrix} -5 \u0026amp; 4 \u0026amp; 0\\\\ 0 \u0026amp; 2 \u0026amp; 0\\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\) Filtro Afilado # Aquellos pixeles con vecinos distintos se potencian. Hace uso de la siguiente matriz:\n\\( \\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 1 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix} \\) Filtro de Desenfoque # Hace que la imagen sea borrosa con un proceso Gaussiano. Usa de la siguiente matriz:\n\\( \\begin{bmatrix} 1/9 \u0026amp; 1/9 \u0026amp; 1/9\\\\ 1/9 \u0026amp; 1/9 \u0026amp; 1/9\\\\ 1/9 \u0026amp; 1/9 \u0026amp; 1/9 \\end{bmatrix} \\) Los filtros se aplican según la tecla que ingrese el usuario\n1 aplica el filtro de Sobreexposición 2 aplica el filtro de Detección de bordes uniforme 3 aplica el filtro de Detección de bordes vertical 4 aplica el filtro de Detección de bordes horizontal 5 aplica el filtro de Afilado 6 aplica el filtro de desenfoque gaussiano Código Fuente let img; let matriz; function preload() { img = loadImage(\u0026#34;/visualcomputing/sketches/minimagen.jpg\u0026#34;); } function setup() { createCanvas(img.width*2, img.height); } function draw() { image(img, 0, 0); if (key === \u0026#34;1\u0026#34;) { filtrado([[-1, -1, -1 ], [ -1, 9, -1 ], [-1, -1, -1 ]]) } else if (key === \u0026#34;2\u0026#34;) { filtrado([[-1, -1, -1],[-1, 8, -1],[-1, -1, -1]]) } else if (key === \u0026#34;3\u0026#34;) { filtrado([[1, 2, 1],[0, 0, 0],[-1, -2, -1]]) } else if (key === \u0026#34;4\u0026#34;) { filtrado([[-5, 4, 0],[0, 2, 0],[0, -1, 0]]) } else if (key === \u0026#34;5\u0026#34;) { filtrado([[-2, -1, 0],[-1, 1, 1],[0, 1, 2]]) } else if (key === \u0026#34;6\u0026#34;) { filtrado([[1/9, 1/9, 1/9],[1/9, 1/9, 1/9],[1/9, 1/9, 1/9]]) } } function filtrado(m) { matriz = m; newImg = createImage(img.width,img.height); newImg.loadPixels(); for (let x = 1; x \u0026lt; img.width - 1; x++) { for (let y = 1; y \u0026lt; img.height - 1; y++) { let suma=0; let suma2=0; let suma3=0; for (kx = -1; kx \u0026lt;= 1; kx++) { for (ky = -1; ky \u0026lt;= 1; ky++) { let posx= x+kx; let posy=y+ky; let pos = (y + ky)*img.width + (x + kx); let px= red(img.get(posx, posy)); let px2=green(img.get(posx, posy)); let px3=blue(img.get(posx, posy)); suma += matriz[ky+1][kx+1] * px; suma2 += matriz[ky+1][kx+1] * px2; suma3 += matriz[ky+1][kx+1] * px3; } } newImg.set(x, y, color(suma,suma2,suma3)); } } newImg.updatePixels(); image(newImg,img.width,0); } Histograma de los canales RGB # En este histograma se dibuja la imagen de fondo y por encima se describen los histogramas para cada canal de color, en donde el eje X es el valor de ese canal (0 a 255) y en el eje Y el número de ocurrencias de ese valor en la imagen.\nCódigo Fuente let img; let R=[]; let G=[]; let B=[]; function preload() { img = loadImage(\u0026#34;/visualcomputing/sketches/imagen.jpg\u0026#34;); for(var i=0; i\u0026lt;256;i++){ R[i]=0; G[i]=0; B[i]=0; } } function setup() { createCanvas(600, 850); background(255); noLoop(); } function draw() { image(img, 0, 0); loadPixels(); for(var x=0;x\u0026lt;img.width;x++){ for(var y=0; y\u0026lt;img.height;y++){ var px= (x+y*img.width)*4; R[pixels[px+0]]+=1; G[pixels[px+1]]+=1; B[pixels[px+2]]+=1; } } fill(255,255,255,150); noStroke(); rect(50,height/4,255,-150); rect(50,height/4*2,255,-150); rect(50,height/4*3,255,-150); for(var i=0; i\u0026lt;256;i++){ stroke(255,0,0); line(50+i,height/4,50+i,height/4-norm(R[i],0,100)); stroke(0,255,0); line(50+i,height/4*2,50+i,height/4*2-norm(G[i],0,100)); stroke(0,0,255); line(50+i,height/4*3,50+i,height/4*3-norm(B[i],0,100)); } fill(0); noStroke(); textSize(35); textStyle(BOLD); text(\u0026#39; Canal Rojo\u0026#39;, 305, height/4); text(\u0026#39; Canal Verde\u0026#39;, 305, height/4*2); text(\u0026#39; Canal Azul\u0026#39;, 305, height/4*3); } "},{"id":3,"href":"/visualcomputing/docs/talleres/SegundoTaller/","title":"Segundo Taller","section":"Talleres","content":" SegundoTaller # Para la implementación del segúndo taller decidimos usar como base La atracción de Mundo Aventura \u0026ldquo;Ikaro\u0026rdquo;. La complejidad de su implementación radica en la gran cantidad de movimientos que realiza, para lo cual se deben hacer traslaciones y rotaciones anidadas, lo que lo convierte en un proyecto interesante a simular.\nFuncionamiento # El mecanismo de esta atracción funciona de la siguiente forma:\nEl brazo principal sube la rueda cuando la atracción inicia, de forma que pasa de 0 a 90 grados respecto a los ejes X,Y en los primeros segundos. La rueda comienza a rotar en la dirección de las manecillas del reloj, desde una velocidad 0 a una velocidad máxima en los primeros 10 segundos aproximadamente. En cada uno de los 6 brazos que se conectan con la rueda, se encuentran dos parejas de asientos, los cuales rotan bajo su propio eje a velocidades variables entre si. El brazo principal también gira bajo su propio eje cada 30 segundos, rota hasta 180 grados en dirección inversa a las manecillas del reloj durante 10 segundos, permanece 10 segundos en esa posición y durante los siguientes 10 segundos vuelve a su posición inicial rotando 180 grados en dirección de las manecillas del reloj. Para su modelamiento se aplicó una serie sucesiva de traslaciones y rotaciones a todos los componentes del mecanismo de manera anidada. No se usó ninguna referencia para el modelado de la atracción, solo los videos e imágenes obtenidas del mismo.\nInstrucciones de uso # Para interactuar con la simulación se hace uso del mouse, es posible rotar alrededor del mecanismo moviendo el mouse en el eje Y, también es posible hacer Zoom en el mecanismo moviendo el mouse en el eje X.\nDe igual manera, es posible usar el checkbox ubicado en la parte inferior del canvas para aplicar las texturas.\nCódigo Fuente //OBJETOS let silla; let cube; let pipe; //Texturas let tubo; let led; let metal; let metal_rojo; let metal_azul; let texturas=0; //Variables de rotación y traslación generales let trans1=0; let rot1=0; let speed=2.5; //Variables de rotación carritos let speeds=[]; let duration=[]; let rotations=[]; //FONDO let fondo; function preload(){ silla= loadModel(\u0026#39;/visualcomputing/sketches/silla.obj\u0026#39;); cube=loadModel(\u0026#39;/visualcomputing/sketches/cube.obj\u0026#39;); pipe=loadModel(\u0026#39;/visualcomputing/sketches/pipe.obj\u0026#39;); tubo=loadImage(\u0026#39;/visualcomputing/sketches/tubo.jpg\u0026#39;); led=loadImage(\u0026#39;/visualcomputing/sketches/led.jpg\u0026#39;); metal=loadImage(\u0026#39;/visualcomputing/sketches/metal.jpg\u0026#39;); metal_rojo=loadImage(\u0026#39;/visualcomputing/sketches/metal_rojo.jpg\u0026#39;); metal_azul=loadImage(\u0026#39;/visualcomputing/sketches/metal_azul.jpg\u0026#39;); fondo=loadImage(\u0026#39;/visualcomputing/sketches/FONDO.jpg\u0026#39;); } function setup(){ checkbox = createCheckbox(\u0026#39;Texturas\u0026#39;, false); checkbox.changed(myCheckedEvent); createCanvas(600,600,WEBGL); for(let x=0;x\u0026lt;6;x++){ speeds[x]=[]; duration[x]=[]; rotations[x]=[]; for(let y=0;y\u0026lt;2;y++){ speeds[x][y]=random(-0.03,0.03); duration[x][y]=random(4,9); rotations[x][y]=0; } } } function draw(){ background(80); translate(0,0,map(mouseX,0,width+width/2,150,-width*3)); rotateY(map(mouseY,0,height,0,2*PI)); noStroke(); normalMaterial(); if(texturas==1){ texture(fondo); sphere(4000-mouseX); } let sec=millis()/1000; push(); //BASE rotateX(PI); scale(2); translate(0,-20,-10); if(texturas==1){texture(tubo);} model(pipe); pop(); push();//ESFERAS QUE CONECTAN AL TUBO CENTRAL translate(0,-100,0); sphere(50); translate(0,-20,0); sphere(50); pop(); //TUBO CENTRAL if(texturas==1){texture(metal_azul);} if(sec\u0026gt;0\u0026amp;\u0026amp;trans1\u0026lt;350){ translate(0,-120-trans1,-350+trans1); rotateX(map(trans1,0,350,PI/2,0)); trans1+=0.5; } else{ translate(0,-470,0); } if(sec%50\u0026gt;=20\u0026amp;\u0026amp;sec%50\u0026lt;30){ rotateY(map(sec%50,20,30,0,PI)); } if(sec%50\u0026gt;=30\u0026amp;\u0026amp;sec%50\u0026lt;40){ rotateY(PI); } if(sec%50\u0026gt;=40){ rotateY(map(sec%50,40,50,PI,0)); } cylinder(70,700); translate(0,-350,0); if(texturas==1){texture(metal_rojo);} cylinder(80,200); rotateX(PI/2); if(texturas==1){texture(metal);} torus(100,10); cylinder(50,500); translate(0,-350,0); push(); //Bola de pinchos rotateX(PI); scale(5); translate(0,-20,0); if(texturas==1){texture(metal_rojo);} model(cube); pop(); if(sec\u0026gt;2){ rotateX(-PI/2);//Base de los brazos rotateZ(rot1); translate(0,0,150); if(texturas==1){texture(led);} torus(80,80); for(let x=0; x\u0026lt;6;x+=1){//BRAZOS push(); rotateZ(PI/3*x); translate(400,0,0); if(texturas==1){texture(metal_azul);} box(550,100,100); translate(200,0,0); box(40,40,200); push(); rotateX(-PI/2); model(pipe); translate(0,200,0); if(texturas==1){texture(metal_rojo);} box(40,200,40); for(let i=0; i\u0026lt;2;i++){ push(); rotateZ(rotations[x][i]); rotateX(-PI/2); rotateY(-PI/2); rotateX(PI/2); rotateY(PI*i); translate(0,0,10*i); translate(0,-50,50); if(texturas==1){texture(metal);} model(silla); translate(50,0,0); model(silla); pop(); } pop(); pop(); } if(rot1\u0026lt;speed){ rot1+=0.01*sec; } else{ rot1+=0.01*speed; } } for(let x=0;x\u0026lt;6;x++){ for(let y=0;y\u0026lt;2;y++){ duration[x][y]-=1; if(duration[x][y]==0){ durations[x][y]=random(4,9); if(speeds[x][y]\u0026gt;0){ speeds[x][y]=random(-0.03,-0.02); } else{ speeds[x][y]=random(0.02,0.03); } } rotations[x][y]+=speeds[x][y]; } } camera(0,0,(height/2) / tan(PI/6),0,-330,0,0,1,0); } function myCheckedEvent() { if (checkbox.checked()) { texturas=1; } else { texturas=0; } } Recursos # https://www.models-resource.com/ (Modelos en .obj) https://www.youtube.com/ (Videos de la atracción) "},{"id":4,"href":"/visualcomputing/docs/talleres/Tercer-Taller/Coloring/","title":"Coloring","section":"Tercer Taller","content":" Tercer Taller # Coloring # CMY and RGB Color models # El siguiente canva muestra cómo interpolar los datos de color a lo largo de un triángulo y cómo cambiar entre los modelos de color rgba y cmya\nInstrucciones de uso A medida que el ratón se desplaza dentro del lienzo, es posible observar la interpolación de los colores. Presiona:\nR: Para aleatorizar el triángulo. C: Para cambiar entre los modelos de color rgba y cmya. Código Fuente let colorShader; let cmy; let v1, v2, v3; let color = 255; function preload() { colorShader = readShader(\u0026#39;/shaders/color.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.color4 }); } function setup() { // shaders require WEBGL mode to work createCanvas(600, 450, WEBGL); // https://p5js.org/reference/#/p5/shader shader(colorShader); randomizeTriangle(); } function draw() { background(0); beginShape(TRIANGLES); fill(color); vertex(v1.x, v1.y); fill(\u0026#39;blue\u0026#39;); vertex(v2.x, v2.y); fill(\u0026#39;purple\u0026#39;); vertex(v3.x, v3.y); endShape(); } function randomizeTriangle() { v1 = p5.Vector.random2D(); v2 = p5.Vector.random2D(); v3 = p5.Vector.random2D(); } function keyPressed() { if (key == \u0026#39;c\u0026#39;) { cmy = !cmy; colorShader.setUniform(\u0026#39;cmy\u0026#39;, cmy); } if (key == \u0026#39;r\u0026#39;) { randomizeTriangle(); } } function mouseMoved () { color = color + 2; if (color \u0026gt; 280) { color = 0; } } Para la implementación del tercer taller realizamos un conjunto de ejercicios que implementan conceptos de la matería como Coloring y Shaders. Dos de estos ejercicios están basados en la simulación de La atracción de Mundo Aventura \u0026ldquo;Ikaro\u0026rdquo; del taller 2.\nAñadido al ejercicio del taller 2, se implementaron funcionalidades de Coloring al mecanismo, en donde existen 4 opciones de uso:\nSin Texturas: Usa un Material Normal de P5js y el fondo es blanco, es la opción predeterminada. Multiplicar: Usa el primer color del conjunto de ColorPicker para rellenar la atracción mecánica y el segundo color como fondo, sin embargo, hace un efecto de transparencia en donde los colores se vuelven más oscuros a medida que se sobreponen entre sí, así como las mismas partes de un objeto. Se realiza un efecto de Adición Transparencia: Similar a la opción anterior, se aplica un efecto de transparencia pero los colores se vuelven más claros a medida que se sobreponen entre sí, realizando un efecto de Sustracción Promedio: Los colores del conjunto de ColorPicker se promedian en sus tres canales (RGB) y se aplica el color resultante tanto en el fondo como en la atracción mecánica Instrucciones de uso Para interactuar con la simulación se hace uso del mouse, es posible rotar alrededor del mecanismo moviendo el mouse en el eje Y, también es posible hacer Zoom en el mecanismo moviendo el mouse en el eje X.\nEl selector de la parte inferior permite cambiar las opciones de Coloring, y el conjunto de ColorPicker permite cambiar los colores que están directamente relacionados a las 3 últimas opciones del ejercicio.\nCódigo Fuente //OBJETOS let silla; let cube; let pipe; //Texturas let tubo; let led; let metal; let texturas=0; //Variables de rotación y traslación generales let trans1=0; let rot1=0; let speed=2.5; //Variables de rotación carritos let speeds=[]; let duration=[]; let rotations=[]; //Colores let color1,color2; //Selector let sel; function preload(){ silla= loadModel(\u0026#39;/visualcomputing/sketches/silla.obj\u0026#39;); cube=loadModel(\u0026#39;/visualcomputing/sketches/cube.obj\u0026#39;); pipe=loadModel(\u0026#39;/visualcomputing/sketches/pipe.obj\u0026#39;); tubo=loadImage(\u0026#39;/visualcomputing/sketches/tubo.jpg\u0026#39;); led=loadImage(\u0026#39;/visualcomputing/sketches/led.jpg\u0026#39;); metal=loadImage(\u0026#39;/visualcomputing/sketches/metal.jpg\u0026#39;); } function setup(){ sel = createSelect(); sel.option(\u0026#39;Sin Texturas\u0026#39;); sel.option(\u0026#39;Multiplicar\u0026#39;); sel.option(\u0026#39;Transparencia\u0026#39;); sel.option(\u0026#39;Promedio\u0026#39;); sel.selected(\u0026#39;Sin Texturas\u0026#39;); sel.changed(mySelectEvent); color1 = createColorPicker(\u0026#39;#26a1ed\u0026#39;); color2 = createColorPicker(\u0026#39;#f0c7ea\u0026#39;); createCanvas(600,600,WEBGL); for(let x=0;x\u0026lt;6;x++){ speeds[x]=[]; duration[x]=[]; rotations[x]=[]; for(let y=0;y\u0026lt;2;y++){ speeds[x][y]=random(-0.03,0.03); duration[x][y]=random(4,9); rotations[x][y]=0; } } } function draw(){ background(color2.color()); translate(0,0,map(mouseX,0,width+width/2,150,-width*3)); rotateY(map(mouseY,0,height,0,2*PI)); noStroke(); if(texturas==1){ blendMode(MULTIPLY); ambientLight(color1.color()); directionalLight(255,255,255,0,0,-1); } else if(texturas==2){ blendMode(LIGHTEST); ambientLight(color1.color()); directionalLight(255,255,255,0,0,-1); } else if(texturas==3){ blendMode(NORMAL); let R=(red(color1.color())+red(color2.color()))/2 let G=(green(color1.color())+green(color2.color()))/2 let B=(blue(color1.color())+blue(color2.color()))/2 background(R,G,B); ambientLight(R,G,B); directionalLight(255,255,255,0,0,-1); } else{ background(255); blendMode(NORMAL); normalMaterial(); } let sec=millis()/1000; push(); //BASE rotateX(PI); scale(2); translate(0,-20,-10); if(texturas!=0){texture(metal);} model(pipe); pop(); push();//ESFERAS QUE CONECTAN AL TUBO CENTRAL translate(0,-100,0); sphere(50); translate(0,-20,0); sphere(50); pop(); //TUBO CENTRAL if(texturas!=0){texture(metal);} if(sec\u0026gt;0\u0026amp;\u0026amp;trans1\u0026lt;350){ translate(0,-120-trans1,-350+trans1); rotateX(map(trans1,0,350,PI/2,0)); trans1+=0.5; } else{ translate(0,-470,0); } if(sec%50\u0026gt;=20\u0026amp;\u0026amp;sec%50\u0026lt;30){ rotateY(map(sec%50,20,30,0,PI)); } if(sec%50\u0026gt;=30\u0026amp;\u0026amp;sec%50\u0026lt;40){ rotateY(PI); } if(sec%50\u0026gt;=40){ rotateY(map(sec%50,40,50,PI,0)); } cylinder(70,700); translate(0,-350,0); if(texturas!=0){texture(metal);} cylinder(80,200); rotateX(PI/2); if(texturas!=0){texture(metal);} torus(100,10); cylinder(50,500); translate(0,-350,0); push(); //Bola de pinchos rotateX(PI); scale(5); translate(0,-20,0); if(texturas!=0){texture(metal);} model(cube); pop(); if(sec\u0026gt;2){ rotateX(-PI/2);//Base de los brazos rotateZ(rot1); translate(0,0,150); if(texturas!=0){texture(metal);} torus(80,80); for(let x=0; x\u0026lt;6;x+=1){//BRAZOS push(); rotateZ(PI/3*x); translate(400,0,0); if(texturas!=0){texture(metal);} box(550,100,100); translate(200,0,0); box(40,40,200); push(); rotateX(-PI/2); model(pipe); translate(0,200,0); if(texturas!=0){texture(metal);} box(40,200,40); for(let i=0; i\u0026lt;2;i++){ push(); rotateZ(rotations[x][i]); rotateX(-PI/2); rotateY(-PI/2); rotateX(PI/2); rotateY(PI*i); translate(0,0,10*i); translate(0,-50,50); if(texturas!=0){texture(metal);} model(silla); translate(50,0,0); model(silla); pop(); } pop(); pop(); } if(rot1\u0026lt;speed){ rot1+=0.01*sec; } else{ rot1+=0.01*speed; } } for(let x=0;x\u0026lt;6;x++){ for(let y=0;y\u0026lt;2;y++){ duration[x][y]-=1; if(duration[x][y]==0){ durations[x][y]=random(4,9); if(speeds[x][y]\u0026gt;0){ speeds[x][y]=random(-0.03,-0.02); } else{ speeds[x][y]=random(0.02,0.03); } } rotations[x][y]+=speeds[x][y]; } } camera(0,0,(height/2) / tan(PI/6),0,-330,0,0,1,0); } function mySelectEvent() { switch(sel.value()){ case \u0026#39;Multiplicar\u0026#39;: texturas=1; break; case \u0026#39;Transparencia\u0026#39;: texturas=2; break; case \u0026#39;Promedio\u0026#39;: texturas=3; break; default: texturas=0; } } Recursos # https://www.models-resource.com/ (Modelos en .obj) https://www.youtube.com/ (Videos de la atracción) "},{"id":5,"href":"/visualcomputing/docs/talleres/Tercer-Taller/Texturing/","title":"Texturing","section":"Tercer Taller","content":" Texturing # UV Visualization # El mapeo de texturas es un método para definir detalles de alta frecuencia, texturas superficiales o información de color en un gráfico generado por computadora o en un modelo 3D. La técnica original fue establecida por Edwin Catmull en 1974.\nEl mapeo de texturas originalmente se refería al mapeo difuso, un método que mapeaba píxeles de una textura a una superficie 3D (\u0026ldquo;envolviendo\u0026rdquo; la imagen alrededor del objeto). En las últimas décadas, el advenimiento del renderizado multipaso, multitexturización, mipmaps y mapeos más complejos como el mapeo de altura, el mapeo de relieve, el mapeo normal, el mapeo de desplazamiento, el mapeo de reflexión, el mapeo especular, el mapeo de oclusión y muchas otras variaciones de la técnica. (controlados por un sistema de materiales) han hecho posible simular casi fotorrealismo en tiempo real al reducir enormemente la cantidad de polígonos y cálculos de iluminación necesarios para construir una escena 3D realista y funcional.\nLa textura se define en \u0026ldquo;uv space\u0026rdquo;, que a su vez se puede mostrar de varias formas como la que se muestra a continuación utilizando los colores azul y rojo. En el segundo ejemplo se usa una shape diferente, en este caso es una elipse: Código Fuente // Código adaptado de la página https://visualcomputing.github.io/docs/shaders/texturing/ let uvShader; function preload() { uvShader = readShader(\u0026#39;/shaders/uv.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { createCanvas(600, 450, WEBGL); noStroke(); shader(uvShader); textureMode(NORMAL); } function draw() { background(0); quad(-1, -1, 1, -1, 1, 1, -1, 1); } Código Fuente let uvShader; function preload() { uvShader = readShader(\u0026#39;/shaders/uv.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { createCanvas(600, 450, WEBGL); noStroke(); shader(uvShader); textureMode(NORMAL); } function draw() { background(0); ellipse( -1,1,-1,1); } 3D Screen # Código Fuente // Código adaptado de la página https://visualcomputing.github.io/docs/shaders/texturing/ let easycam; let uvShader; let opacity; function preload() { uvShader = readShader(\u0026#39;/shaders/uv_alpha.frag\u0026#39;, { matrices: Tree.pmvMatrix, varyings: Tree.texcoords2 }); } function setup() { createCanvas(600, 450, WEBGL); let state = { distance: 250, center: [0, 0, 0], rotation: [0, 0, 0, 1], }; easycam = createEasyCam(); easycam.state_reset = state; easycam.setState(state, 2000); textureMode(NORMAL); opacity = createSlider(0, 1, 0.5, 0.01); opacity.position(10, 25); opacity.style(\u0026#39;width\u0026#39;, \u0026#39;280px\u0026#39;); } function draw() { background(200); resetShader(); axes(); grid(); translate(0, 30); fill(color(0, 50, 50, 200)); rotateX(frameCount * 0.01); rotateZ(frameCount * 0.01); cone(40, 70); // use custom shader shader(uvShader); uvShader.setUniform(\u0026#39;opacity\u0026#39;, opacity.value()); beginHUD(); noStroke(); quad(0, 0, width, 0, width, height, 0, height); endHUD(); } function mouseWheel(event) { return false; } Texture sampling # Código Fuente // Código adaptado de la página https://visualcomputing.github.io/docs/shaders/texturing/ let easycam; let uvShader; let opacity; function preload() { uvShader = readShader(\u0026#39;/shaders/uv_alpha.frag\u0026#39;, { matrices: Tree.pmvMatrix, varyings: Tree.texcoords2 }); } function setup() { createCanvas(600, 450, WEBGL); let state = { distance: 250, center: [0, 0, 0], rotation: [0, 0, 0, 1], }; easycam = createEasyCam(); easycam.state_reset = state; easycam.setState(state, 2000); textureMode(NORMAL); opacity = createSlider(0, 1, 0.5, 0.01); opacity.position(10, 25); opacity.style(\u0026#39;width\u0026#39;, \u0026#39;280px\u0026#39;); } function draw() { background(200); resetShader(); axes(); grid(); translate(0, 30); fill(color(0, 50, 50, 200)); rotateX(frameCount * 0.01); rotateZ(frameCount * 0.01); cone(40, 70); // use custom shader shader(uvShader); uvShader.setUniform(\u0026#39;opacity\u0026#39;, opacity.value()); beginHUD(); noStroke(); quad(0, 0, width, 0, width, height, 0, height); endHUD(); } function mouseWheel(event) { return false; } "}]